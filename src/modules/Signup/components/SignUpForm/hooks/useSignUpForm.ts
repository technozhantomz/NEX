import counterpart from "counterpart";
import { ChainValidation } from "peerplaysjs-lib";
import { useState } from "react";

import { utils } from "../../../../../api/utils";
import { useAccount, useCreateAccount } from "../../../../../common/hooks";
import {
  useBrowserHistoryContext,
  useUserContext,
} from "../../../../../common/providers";
import { SignupForm } from "../../../../../common/types";
import { CheckboxChangeEvent, Form } from "../../../../../ui/src";

import { useGeneratePassword } from "./useGeneratePassword";
import { IFormValidation, UseSignUpFormResult } from "./useSignUpForm.types";

export function useSignUpForm(): UseSignUpFormResult {
  const [isInputTypePassword, setIsInputTypePassword] = useState(true);
  const [submitting, setSubmitting] = useState<boolean>(false);

  const { formAccountAfterConfirmation, getFullAccount } = useAccount();
  const { createAccount } = useCreateAccount();
  const { localStorageAccount, setLocalStorageAccount } = useUserContext();
  const [validUser, setValidUser] = useState<boolean>(false);
  const { handleLoginRedirect } = useBrowserHistoryContext();
  const [signUpForm] = Form.useForm<SignupForm>();
  const username = Form.useWatch("username", signUpForm);
  const password = Form.useWatch("password", signUpForm);
  const [autoGeneratedPassword, setAutoGeneratedPassword] =
    useState<string>("");
  const { generatePassword } = useGeneratePassword();

  if (localStorageAccount) {
    handleLoginRedirect();
  }
  if (autoGeneratedPassword === "") {
    const autoGeneratedPassword = generatePassword();
    setAutoGeneratedPassword(autoGeneratedPassword);
  }

  const handleSignUp = async (formData: unknown) => {
    setSubmitting(true);
    try {
      const fullAccount = await createAccount(formData as SignupForm);
      if (typeof fullAccount !== "string") {
        await formAccountAfterConfirmation(fullAccount, "", "");
        setLocalStorageAccount(fullAccount.account.name);
        setSubmitting(false);
      } else {
        const error =
          fullAccount === ""
            ? counterpart.translate(`field.errors.unable_to_create_account`)
            : fullAccount;
        signUpForm.setFields([
          {
            name: "username",
            errors: [error],
          },
        ]);
        setSubmitting(false);
      }
    } catch (e) {
      console.log(e);
      signUpForm.setFields([
        {
          name: "username",
          errors: [
            counterpart.translate(`field.errors.unable_to_create_account`),
          ],
        },
      ]);
      setSubmitting(false);
    }
  };

  const handleInputType = () => {
    setIsInputTypePassword(!isInputTypePassword);
  };

  const setCheckboxValue = (e: CheckboxChangeEvent) => {
    if (e.target.id === "signUpForm_saved")
      signUpForm.setFieldsValue({
        saved: e.target.checked,
      });
    if (e.target.id === "signUpForm_confirm")
      signUpForm.setFieldsValue({
        confirm: e.target.checked,
      });
  };

  const checkPasswordMatch = (_: unknown, value: { passwordCheck: string }) => {
    if (value === signUpForm.getFieldValue("password"))
      return Promise.resolve();
    return Promise.reject(
      new Error(counterpart.translate(`field.errors.password_not_match`))
    );
  };

  const validateUsername = async (_: unknown, value: string) => {
    const fullAccount = await getFullAccount(value, false);
    if (fullAccount) {
      return Promise.reject(
        new Error(counterpart.translate(`field.errors.username_taken`))
      );
    }
    const { isValid, error } = utils.validatePeerplaysAccountName(value);

    if (!isValid) {
      return Promise.reject(new Error(error));
    }
    if (!ChainValidation.is_cheap_name(value)) {
      return Promise.reject(
        new Error(counterpart.translate(`field.errors.premium_username`))
      );
    }

    setValidUser(true);
    return Promise.resolve();
  };

  const validateConfirmation = (_: unknown, value: boolean) => {
    return value
      ? Promise.resolve()
      : Promise.reject(
          new Error(counterpart.translate(`field.errors.confirmation_required`))
        );
  };

  const validateSaved = (_: unknown, value: boolean) => {
    return value
      ? Promise.resolve()
      : Promise.reject(
          new Error(counterpart.translate(`field.errors.save_your_password`))
        );
  };
  const formValidation: IFormValidation = {
    username: [
      {
        required: true,
        message: counterpart.translate(`field.errors.username_required`),
      },
      { validator: validateUsername },
    ],
    password: [
      {
        required: true,
        message: counterpart.translate(`field.errors.password_required`),
      },
      {
        pattern: new RegExp(/^\S*$/),
        message: counterpart.translate(`field.errors.password_white_space`),
      },
      {
        min: 12,
        message: counterpart.translate(`field.errors.password_should_be_long`),
      },
    ],
    passwordCheck: [
      {
        required: true,
        message: counterpart.translate(`field.errors.field_is_required`),
      },
      { validator: checkPasswordMatch },
    ],
    confirm: [{ validator: validateConfirmation }],
    saved: [{ validator: validateSaved }],
  };

  return {
    validUser,
    handleSignUp,
    setCheckboxValue,
    checkPasswordMatch,
    validateUsername,
    formValidation,
    signUpForm,
    submitting,
    autoGeneratedPassword,
    isInputTypePassword,
    handleInputType,
    username,
    password,
  };
}
